import { createNamespace } from 'skyline/src/utils/namespace';
import {
  GestureDetail,
  Side,
} from 'skyline/src/types/interface';
import { createGesture } from 'skyline/src/utils/gesture';
// import { Vue } from 'vue/types/vue';

const { createComponent, bem } = /*#__PURE__*/ createNamespace('item-sliding');

const SWIPE_MARGIN = 30;
const ELASTIC_FACTOR = 0.55;

const enum ItemSide {
  None = 0,
  Start = 1 << 0,
  End = 1 << 1,
  Both = Start | End
}

const enum SlidingState {
  Disabled = 1 << 1,
  Enabled = 1 << 2,
  End = 1 << 3,
  Start = 1 << 4,

  SwipeEnd = 1 << 5,
  SwipeStart = 1 << 6,
}

let openSlidingItem: any | undefined;

const isEndSide = (side: Side): boolean => {
  const isRTL = document.dir === 'rtl';
  switch (side) {
    case 'start': return isRTL;
    case 'end': return !isRTL;
    default:
      throw new Error(`"${ side }" is not a valid value for [side]. Use "start" or "end" instead.`);
  }
};

const swipeShouldReset = (isResetDirection: boolean, isMovingFast: boolean, isOnResetZone: boolean): boolean => {
  // The logic required to know when the sliding item should close (openAmount=0)
  // depends on three booleans (isResetDirection, isMovingFast, isOnResetZone)
  // and it ended up being too complicated to be written manually without errors
  // so the truth table is attached below: (0=false, 1=true)
  // isResetDirection | isMovingFast | isOnResetZone || shouldClose
  //         0        |       0      |       0       ||    0
  //         0        |       0      |       1       ||    1
  //         0        |       1      |       0       ||    0
  //         0        |       1      |       1       ||    0
  //         1        |       0      |       0       ||    0
  //         1        |       0      |       1       ||    1
  //         1        |       1      |       0       ||    1
  //         1        |       1      |       1       ||    1
  // The resulting expression was generated by resolving the K-map (Karnaugh map):
  return (!isMovingFast && isOnResetZone) || (isResetDirection && isMovingFast);
};

export default /*#__PURE__*/ createComponent({
  provide(): any {
    return {
      ItemSliding : this,
    };
  },

  inject : {
    Item : { default: undefined },
  },

  props : {
    disabled : {
      type    : Boolean,
      default : false,
    },
  },

  data() {
    return {
      state : SlidingState.Disabled,

      options : [] as any[],
    };
  },

  methods : {
    disabledChanged() {
      if (this.gesture) {
        this.gesture.enable(!this.disabled);
      }
    },

    /**
     * Get the amount the item is open in pixels.
     */
    getOpenAmount(): Promise<number> {
      return Promise.resolve(this.openAmount);
    },

    /**
     * Get the ratio of the open amount of the item compared to the width of the options.
     * If the number returned is positive, then the options on the right side are open.
     * If the number returned is negative, then the options on the left side are open.
     * If the absolute value of the number is greater than 1, the item is open more than
     * the width of the options.
     */
    getSlidingRatio(): Promise<number> {
      return Promise.resolve(this.getSlidingRatioSync());
    },

    /**
     * Open the sliding item.
     *
     * @param side The side of the options to open. If a side is not provided,
     * it will open the first set of options it finds within the item.
     */
    async open(side: Side | undefined) {
      if (this.item === null) { return; }

      const optionsToOpen = this.getOptions(side);
      if (!optionsToOpen) { return; }

      /**
       * If side is not set, we need to infer the side
       * so we know which direction to move the options
       */
      if (side === undefined) {
        side = (optionsToOpen === this.leftOptions) ? 'start' : 'end';
      }

      // In RTL we want to switch the sides
      side = isEndSide(side) ? 'end' : 'start';

      const isStartOpen = this.openAmount < 0;
      const isEndOpen = this.openAmount > 0;

      /**
       * If a side is open and a user tries to
       * re-open the same side, we should not do anything
       */
      if (isStartOpen && optionsToOpen === this.leftOptions) { return; }
      if (isEndOpen && optionsToOpen === this.rightOptions) { return; }

      this.closeOpened();

      this.state = SlidingState.Enabled;

      requestAnimationFrame(() => {
        this.calculateOptsWidth();

        const width = (side === 'end') ? this.optsWidthRightSide : -this.optsWidthLeftSide;
        openSlidingItem = this;

        this.setOpenAmount(width, false);
        this.state = (side === 'end') ? SlidingState.End : SlidingState.Start;
      });
    },

    /**
     * Close the sliding item. Items can also be closed from the [List](../list).
     */
    async close() {
      this.setOpenAmount(0, true);
    },

    /**
     * Close all of the sliding items in the list. Items can also be closed from the [List](../list).
     */
    async closeOpened(): Promise<boolean> {
      if (openSlidingItem !== undefined) {
        openSlidingItem.close();
        openSlidingItem = undefined;
        return true;
      }
      return false;
    },

    /**
     * Given an optional side, return the line-item-options element.
     *
     * @param side This side of the options to get. If a side is not provided it will
     * return the first one available.
     */
    getOptions(side?: string): HTMLElement | undefined {
      if (side === undefined) {
        return this.leftOptions || this.rightOptions;
      } if (side === 'start') {
        return this.leftOptions;
      }
      return this.rightOptions;
    },

    async updateOptions() {
      const { options } = this;

      let sides = 0;

      // Reset left and right options in case they were removed
      this.leftOptions = this.rightOptions = undefined;

      for (let i = 0; i < options.length; i++) {
        const option = await options[i];

        const side = isEndSide(option.side) ? 'end' : 'start';

        if (side === 'start') {
          this.leftOptions = option;
          sides |= ItemSide.Start;
        } else {
          this.rightOptions = option;
          sides |= ItemSide.End;
        }
      }
      this.optsDirty = true;
      this.sides = sides;
    },

    canStart(gesture: GestureDetail): boolean {
      /**
       * If very close to start of the screen
       * do not open left side so swipe to go
       * back will still work.
       */
      const rtl = document.dir === 'rtl';
      const atEdge = (rtl) ? (window.innerWidth - gesture.startX) < 15 : gesture.startX < 15;
      if (atEdge) {
        return false;
      }
      const selected = openSlidingItem;

      if (selected && selected !== this) {
        this.closeOpened();
        return false;
      }

      return !!(this.rightOptions || this.leftOptions);
    },

    onStart() {
      openSlidingItem = this;

      if (this.tmr !== undefined) {
        clearTimeout(this.tmr);
        this.tmr = undefined;
      }
      if (this.openAmount === 0) {
        this.optsDirty = true;
        this.state = SlidingState.Enabled;
      }
      this.initialOpenAmount = this.openAmount;
      if (this.item) {
        this.item.style.transition = 'none';
      }
    },

    onMove(gesture: GestureDetail) {
      if (this.optsDirty) {
        this.calculateOptsWidth();
      }
      let openAmount = this.initialOpenAmount - gesture.deltaX;

      switch (this.sides) {
        case ItemSide.End: openAmount = Math.max(0, openAmount); break;
        case ItemSide.Start: openAmount = Math.min(0, openAmount); break;
        case ItemSide.Both: break;
        case ItemSide.None: return;
        default: console.warn('invalid ItemSideFlags value', this.sides); break;
      }

      let optsWidth;
      if (openAmount > this.optsWidthRightSide) {
        optsWidth = this.optsWidthRightSide;
        openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;
      } else if (openAmount < -this.optsWidthLeftSide) {
        optsWidth = -this.optsWidthLeftSide;
        openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;
      }

      this.setOpenAmount(openAmount, false);
    },

    onEnd(gesture: GestureDetail) {
      const velocity = gesture.velocityX;

      let restingPoint = (this.openAmount > 0)
        ? this.optsWidthRightSide
        : -this.optsWidthLeftSide;

      // Check if the drag didn't clear the buttons mid-point
      // and we aren't moving fast enough to swipe open
      const isResetDirection = (this.openAmount > 0) === !(velocity < 0);
      const isMovingFast = Math.abs(velocity) > 0.3;
      const isOnCloseZone = Math.abs(this.openAmount) < Math.abs(restingPoint / 2);
      if (swipeShouldReset(isResetDirection, isMovingFast, isOnCloseZone)) {
        restingPoint = 0;
      }

      const { state } = this;
      this.setOpenAmount(restingPoint, true);

      if ((state & SlidingState.SwipeEnd) !== 0 && this.rightOptions) {
        this.rightOptions.fireSwipeEvent();
      } else if ((state & SlidingState.SwipeStart) !== 0 && this.leftOptions) {
        this.leftOptions.fireSwipeEvent();
      }
    },

    calculateOptsWidth() {
      this.optsWidthRightSide = 0;
      if (this.rightOptions) {
        this.rightOptions.$el.style.display = 'flex';
        this.optsWidthRightSide = this.rightOptions.$el.offsetWidth;
        this.rightOptions.$el.style.display = '';
      }

      this.optsWidthLeftSide = 0;
      if (this.leftOptions) {
        this.leftOptions.$el.style.display = 'flex';
        this.optsWidthLeftSide = this.leftOptions.$el.offsetWidth;
        this.leftOptions.$el.style.display = '';
      }

      this.optsDirty = false;
    },

    setOpenAmount(openAmount: number, isFinal: boolean) {
      if (this.tmr !== undefined) {
        clearTimeout(this.tmr);
        this.tmr = undefined;
      }
      if (!this.item) {
        return;
      }
      const { style } = this.item;
      this.openAmount = openAmount;

      if (isFinal) {
        style.transition = '';
      }

      if (openAmount > 0) {
        this.state = (openAmount >= (this.optsWidthRightSide + SWIPE_MARGIN))
          ? SlidingState.End | SlidingState.SwipeEnd
          : SlidingState.End;
      } else if (openAmount < 0) {
        this.state = (openAmount <= (-this.optsWidthLeftSide - SWIPE_MARGIN))
          ? SlidingState.Start | SlidingState.SwipeStart
          : SlidingState.Start;
      } else {
        this.tmr = setTimeout(() => {
          this.state = SlidingState.Disabled;
          this.tmr = undefined;
        }, 600) as any;

        openSlidingItem = undefined;
        style.transform = '';
        return;
      }

      style.transform = `translate3d(${ -openAmount }px,0,0)`;

      this.$emit('drag', {
        amount : openAmount,
        ratio  : this.getSlidingRatioSync(),
      });
    },

    getSlidingRatioSync(): number {
      if (this.openAmount > 0) {
        return this.openAmount / this.optsWidthRightSide;
      } if (this.openAmount < 0) {
        return this.openAmount / this.optsWidthLeftSide;
      }
      return 0;
    },
  },

  beforeMount() {
    this.item = null as (HTMLElement | null);
    this.openAmount = 0;
    this.initialOpenAmount = 0;
    this.optsWidthRightSide = 0;
    this.optsWidthLeftSide = 0;
    this.sides = ItemSide.None;
    this.tmr = undefined as (number | undefined);
    this.optsDirty = true;
  },

  async mounted() {
    this.item = this.$el.querySelector('.line-item');
    await this.updateOptions();

    this.gesture = createGesture({
      el              : this.$el,
      gestureName     : 'item-swipe',
      gesturePriority : 100,
      threshold       : 5,
      canStart        : ev => this.canStart(ev),
      onStart         : () => this.onStart(),
      onMove          : ev => this.onMove(ev),
      onEnd           : ev => this.onEnd(ev),
    });
    this.disabledChanged();
  },


  render() {
    return (
      <div
        class={
          bem({
            'active-slide'         : (this.state !== SlidingState.Disabled),
            'active-options-end'   : (this.state & SlidingState.End) !== 0,
            'active-options-start' : (this.state & SlidingState.Start) !== 0,
            'active-swipe-end'     : (this.state & SlidingState.SwipeEnd) !== 0,
            'active-swipe-start'   : (this.state & SlidingState.SwipeStart) !== 0,
          })
        }
      >
        {this.slots()}
      </div>
    );
  },
});
